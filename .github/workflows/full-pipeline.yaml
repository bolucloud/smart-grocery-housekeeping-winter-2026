name: Full Deployment CI/CD Pipeline

on:
  push:
    branches:
    - main
    paths:
    - 'infrastructure/**'
    - 'backend/**'
    - '.github/workflows/**'
  pull_request:
    types: [ opened, edited, reopened, synchronize ]
    branches:
    - main
    paths:
    - 'infrastructure/**'
    - 'backend/**'
    - '.github/workflows/**'

env:
  TF_VERSION: 1.14.3
  AWS_REGION: us-east-1
  ECR_REPOSITORY: smart-grocery-housekeeping
  ECS_SERVICE: smart-grocery-housekeeping-backend-service
  ECS_CLUSTER: smart-grocery-housekeeping-ecs-cluster
  ECS_TASK_DEFINITION: infrastructure/backend_taskdef.json
  CONTAINER_NAME: fastapi-backend
  DOCKERFILE_PATH: ./Dockerfile
  DOCKER_CONTEXT: default
  DATABASE_URL: ${{ secrets.DATABASE_URL }}

permissions:
  contents: read
  id-token: write
  actions: read
  checks: write
  pull-requests: write

jobs:
  check-issue-link:
    name: Check for Linked Issue
    runs-on: self-hosted
    steps:
    - name: Check for linked issue
      id: check_linked_issue
      if: github.event_name == 'pull_request'
      run: |
        PR_TITLE="${{ github.event.pull_request.title }}"
        PR_BODY="${{ github.event.pull_request.body || '' }}"
        if ! echo "$PR_BODY" | grep -q "https://github.com/bolucloud/smart-grocery-housekeeping-winter-2026/issues/[0-9]\+"; then
          echo "Pull Request does not reference a linked issue. Please link an issue in the PR description."
          echo "has_linked_issue=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "Pull Request has a linked issue."
          echo "has_linked_issue=true" >> $GITHUB_OUTPUT
        fi

  terraform:
    name: Run Terraform CI/CD
    runs-on: self-hosted

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform initialize
      run: terraform init
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
      working-directory: ./infrastructure

    # - name: Terraform format
    #   run: terraform fmt -check
    #   working-directory: ./infrastructure

    - name: Terraform validate
      run: terraform validate
      working-directory: ./infrastructure

    - name: Terraform plan
      if: github.event_name == 'pull_request'
      run: terraform plan -no-color -input=false
      working-directory: ./infrastructure
    - name: Terraform apply
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: terraform apply -auto-approve -input=false
      working-directory: ./infrastructure

  tests:
    name: Run Python tests
    runs-on: self-hosted
    # if: github.event_name == 'pull_request'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
        pip install pytest pytest-asyncio pytest-cov httpx pydantic 'pydantic[email]' fastapi firebase-admin sqlalchemy dotenv psycopg2 psycopg2-binary 

    - name: Run tests
      run: |
        pytest --cov=backend backend/tests/

  build-and-deploy:
    name: Build Backend Image and Deploy
    #if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: self-hosted
    needs: [ check-issue-link, terraform, tests ]
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Clean Docker context
      run: |
        # Remove problematic Docker context
        rm -rf ~/.docker/contexts
        # Reset to default context
        docker context use default

    - name: Login to AWS ECR
      id: login-ecr-bash
      run: |
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 480428003157.dkr.ecr.us-east-1.amazonaws.com

    # - name: Login to AWS ECR
    #   id: login-ecr
    #   uses: aws-actions/amazon-ecr-login@v2
    #   with:
    #     mask-password: true





    # - name: Setup Docker Buildx
    #   uses: docker/setup-buildx-action@v3

    - name: Build docker image
      id: build-image
      run: |
        cp backend/requirements.txt .  # Copy requirements.txt to root for Docker build context
        ECR_REPO_URI="480428003157.dkr.ecr.us-east-1.amazonaws.com/smart-grocery-housekeeping"
        MAJOR_MINOR_VERSION="1.0"
        BUILD_NUMBER=${GITHUB_RUN_NUMBER}
        VERSION="${MAJOR_MINOR_VERSION}-${BUILD_NUMBER}"
        docker build --platform linux/amd64 --build-arg "DATABASE_URL=${{ secrets.DATABASE_URL }}" -t ${ECR_REPO_URI}:$VERSION -t ${ECR_REPO_URI}:latest -f backend/Dockerfile .

    - name: Push docker image to ECR
      id: push-to-ecr
      run: |
        ECR_REPO_URI="480428003157.dkr.ecr.us-east-1.amazonaws.com/smart-grocery-housekeeping"
        MAJOR_MINOR_VERSION="1.0"
        BUILD_NUMBER=${GITHUB_RUN_NUMBER}
        VERSION="${MAJOR_MINOR_VERSION}-${BUILD_NUMBER}"

        docker push ${ECR_REPO_URI}:$VERSION
        docker push ${ECR_REPO_URI}:latest
        echo "ecr_image_uri=${ECR_REPO_URI}:$VERSION" >> $GITHUB_OUTPUT

    - name: Force New ECS Deployment on new image build
      run: |
        # Force new deployment with existing task definition
        aws ecs update-service \
          --cluster ${ECS_CLUSTER} \
          --service ${ECS_SERVICE} \
          --force-new-deployment \
          --region ${AWS_REGION}
        # echo "do nothing for now....uncomment this step when service is up and running in ecs"
